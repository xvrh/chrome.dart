import 'dart:typed_data';

import 'src/internal_helpers.dart';
import 'src/js/usb.dart' as $js;

export 'src/chrome.dart' show chrome;

final _usb = ChromeUsb._();

extension ChromeUsbExtension on Chrome {
  /// Use the `chrome.usb` API to interact with connected USB
  /// devices. This API provides access to USB operations from within the
  /// context
  /// of an app. Using this API, apps can function as drivers for hardware
  /// devices.
  ///
  /// Errors generated by this API are reported by setting
  /// [runtime.lastError] and executing the function's regular callback. The
  /// callback's regular parameters will be undefined in this case.
  ChromeUsb get usb => _usb;
}

class ChromeUsb {
  ChromeUsb._();

  bool get isAvailable => $js.chrome.usbNullable != null;

  /// Enumerates connected USB devices.
  /// |options|: The properties to search for on target devices.
  Future<List<Device>> getDevices(EnumerateDevicesOptions options) {
    var $completer = Completer<List<Device>>();
    $js.chrome.usb.getDevices(
      options.toJS,
      (JSArray devices) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(devices.toDart
              .cast<$js.Device>()
              .map((e) => Device.fromJS(e))
              .toList());
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Presents a device picker to the user and returns the [Device]s
  /// selected.
  /// If the user cancels the picker devices will be empty. A user gesture
  /// is required for the dialog to display. Without a user gesture, the
  /// callback will run as though the user cancelled.
  /// |options|: Configuration of the device picker dialog box.
  /// |callback|: Invoked with a list of chosen [Device]s.
  Future<List<Device>> getUserSelectedDevices(DevicePromptOptions options) {
    var $completer = Completer<List<Device>>();
    $js.chrome.usb.getUserSelectedDevices(
      options.toJS,
      (JSArray devices) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(devices.toDart
              .cast<$js.Device>()
              .map((e) => Device.fromJS(e))
              .toList());
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Returns the full set of device configuration descriptors.
  /// |device|: The [Device] to fetch descriptors from.
  Future<List<ConfigDescriptor>> getConfigurations(Device device) {
    var $completer = Completer<List<ConfigDescriptor>>();
    $js.chrome.usb.getConfigurations(
      device.toJS,
      (JSArray configs) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(configs.toDart
              .cast<$js.ConfigDescriptor>()
              .map((e) => ConfigDescriptor.fromJS(e))
              .toList());
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Requests access from the permission broker to a device claimed by
  /// Chrome OS if the given interface on the device is not claimed.
  ///
  /// |device|: The [Device] to request access to.
  /// |interfaceId|: The particular interface requested.
  Future<bool> requestAccess(
    Device device,
    int interfaceId,
  ) {
    var $completer = Completer<bool>();
    $js.chrome.usb.requestAccess(
      device.toJS,
      interfaceId,
      (bool success) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(success);
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Opens a USB device returned by [getDevices].
  /// |device|: The [Device] to open.
  Future<ConnectionHandle> openDevice(Device device) {
    var $completer = Completer<ConnectionHandle>();
    $js.chrome.usb.openDevice(
      device.toJS,
      ($js.ConnectionHandle handle) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(ConnectionHandle.fromJS(handle));
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Finds USB devices specified by the vendor, product and (optionally)
  /// interface IDs and if permissions allow opens them for use.
  ///
  /// If the access request is rejected or the device fails to be opened a
  /// connection handle will not be created or returned.
  ///
  /// Calling this method is equivalent to calling [getDevices] followed
  /// by [openDevice] for each device.
  ///
  /// |options|: The properties to search for on target devices.
  Future<List<ConnectionHandle>> findDevices(
      EnumerateDevicesAndRequestAccessOptions options) {
    var $completer = Completer<List<ConnectionHandle>>();
    $js.chrome.usb.findDevices(
      options.toJS,
      (JSArray handles) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(handles.toDart
              .cast<$js.ConnectionHandle>()
              .map((e) => ConnectionHandle.fromJS(e))
              .toList());
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Closes a connection handle. Invoking operations on a handle after it
  /// has been closed is a safe operation but causes no action to be taken.
  /// |handle|: The [ConnectionHandle] to close.
  Future<void> closeDevice(ConnectionHandle handle) {
    var $completer = Completer<void>();
    $js.chrome.usb.closeDevice(
      handle.toJS,
      () {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(null);
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Select a device configuration.
  ///
  /// This function effectively resets the device by selecting one of the
  /// device's available configurations. Only configuration values greater
  /// than `0` are valid however some buggy devices have a working
  /// configuration `0` and so this value is allowed.
  /// |handle|: An open connection to the device.
  Future<void> setConfiguration(
    ConnectionHandle handle,
    int configurationValue,
  ) {
    var $completer = Completer<void>();
    $js.chrome.usb.setConfiguration(
      handle.toJS,
      configurationValue,
      () {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(null);
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Gets the configuration descriptor for the currently selected
  /// configuration.
  /// |handle|: An open connection to the device.
  Future<ConfigDescriptor> getConfiguration(ConnectionHandle handle) {
    var $completer = Completer<ConfigDescriptor>();
    $js.chrome.usb.getConfiguration(
      handle.toJS,
      ($js.ConfigDescriptor config) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(ConfigDescriptor.fromJS(config));
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Lists all interfaces on a USB device.
  /// |handle|: An open connection to the device.
  Future<List<InterfaceDescriptor>> listInterfaces(ConnectionHandle handle) {
    var $completer = Completer<List<InterfaceDescriptor>>();
    $js.chrome.usb.listInterfaces(
      handle.toJS,
      (JSArray descriptors) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(descriptors.toDart
              .cast<$js.InterfaceDescriptor>()
              .map((e) => InterfaceDescriptor.fromJS(e))
              .toList());
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Claims an interface on a USB device.
  /// Before data can be transfered to an interface or associated endpoints the
  /// interface must be claimed. Only one connection handle can claim an
  /// interface at any given time. If the interface is already claimed, this
  /// call will fail.
  ///
  /// [releaseInterface] should be called when the interface is no longer
  /// needed.
  ///
  /// |handle|: An open connection to the device.
  /// |interfaceNumber|: The interface to be claimed.
  Future<void> claimInterface(
    ConnectionHandle handle,
    int interfaceNumber,
  ) {
    var $completer = Completer<void>();
    $js.chrome.usb.claimInterface(
      handle.toJS,
      interfaceNumber,
      () {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(null);
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Releases a claimed interface.
  /// |handle|: An open connection to the device.
  /// |interfaceNumber|: The interface to be released.
  Future<void> releaseInterface(
    ConnectionHandle handle,
    int interfaceNumber,
  ) {
    var $completer = Completer<void>();
    $js.chrome.usb.releaseInterface(
      handle.toJS,
      interfaceNumber,
      () {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(null);
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Selects an alternate setting on a previously claimed interface.
  /// |handle|: An open connection to the device where this interface has been
  ///     claimed.
  /// |interfaceNumber|: The interface to configure.
  /// |alternateSetting|: The alternate setting to configure.
  Future<void> setInterfaceAlternateSetting(
    ConnectionHandle handle,
    int interfaceNumber,
    int alternateSetting,
  ) {
    var $completer = Completer<void>();
    $js.chrome.usb.setInterfaceAlternateSetting(
      handle.toJS,
      interfaceNumber,
      alternateSetting,
      () {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(null);
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Performs a control transfer on the specified device.
  ///
  /// Control transfers refer to either the device, an interface or an
  /// endpoint. Transfers to an interface or endpoint require the interface to
  /// be claimed.
  ///
  /// |handle|: An open connection to the device.
  Future<TransferResultInfo> controlTransfer(
    ConnectionHandle handle,
    ControlTransferInfo transferInfo,
  ) {
    var $completer = Completer<TransferResultInfo>();
    $js.chrome.usb.controlTransfer(
      handle.toJS,
      transferInfo.toJS,
      ($js.TransferResultInfo info) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(TransferResultInfo.fromJS(info));
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Performs a bulk transfer on the specified device.
  /// |handle|: An open connection to the device.
  /// |transferInfo|: The transfer parameters.
  Future<TransferResultInfo> bulkTransfer(
    ConnectionHandle handle,
    GenericTransferInfo transferInfo,
  ) {
    var $completer = Completer<TransferResultInfo>();
    $js.chrome.usb.bulkTransfer(
      handle.toJS,
      transferInfo.toJS,
      ($js.TransferResultInfo info) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(TransferResultInfo.fromJS(info));
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Performs an interrupt transfer on the specified device.
  /// |handle|: An open connection to the device.
  /// |transferInfo|: The transfer parameters.
  Future<TransferResultInfo> interruptTransfer(
    ConnectionHandle handle,
    GenericTransferInfo transferInfo,
  ) {
    var $completer = Completer<TransferResultInfo>();
    $js.chrome.usb.interruptTransfer(
      handle.toJS,
      transferInfo.toJS,
      ($js.TransferResultInfo info) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(TransferResultInfo.fromJS(info));
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Performs an isochronous transfer on the specific device.
  /// |handle|: An open connection to the device.
  Future<TransferResultInfo> isochronousTransfer(
    ConnectionHandle handle,
    IsochronousTransferInfo transferInfo,
  ) {
    var $completer = Completer<TransferResultInfo>();
    $js.chrome.usb.isochronousTransfer(
      handle.toJS,
      transferInfo.toJS,
      ($js.TransferResultInfo info) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(TransferResultInfo.fromJS(info));
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Tries to reset the USB device.
  /// If the reset fails, the given connection handle will be closed and the
  /// USB device will appear to be disconnected then reconnected.
  /// In this case [getDevices] or [findDevices] must be called again
  /// to acquire the device.
  ///
  /// |handle|: A connection handle to reset.
  Future<bool> resetDevice(ConnectionHandle handle) {
    var $completer = Completer<bool>();
    $js.chrome.usb.resetDevice(
      handle.toJS,
      (bool success) {
        if (checkRuntimeLastError($completer)) {
          $completer.complete(success);
        }
      }.toJS,
    );
    return $completer.future;
  }

  /// Event generated when a device is added to the system. Events are only
  /// broadcast to apps and extensions that have permission to access the
  /// device. Permission may have been granted at install time, when the user
  /// accepted an optional permission (see [permissions.request]), or
  /// through [getUserSelectedDevices].
  Stream<Device> get onDeviceAdded =>
      $js.chrome.usb.onDeviceAdded.asStream(($c) => ($js.Device device) {
            $c.add(Device.fromJS(device));
          }.toJS);

  /// Event generated when a device is removed from the system. See
  /// [onDeviceAdded] for which events are delivered.
  Stream<Device> get onDeviceRemoved =>
      $js.chrome.usb.onDeviceRemoved.asStream(($c) => ($js.Device device) {
            $c.add(Device.fromJS(device));
          }.toJS);
}

/// Direction, Recipient, RequestType, and TransferType all map to their
/// namesakes within the USB specification.
enum Direction {
  in$('in'),
  out('out');

  const Direction(this.value);

  final String value;

  String get toJS => value;
  static Direction fromJS(String value) =>
      values.firstWhere((e) => e.value == value);
}

enum Recipient {
  device('device'),
  interface('_interface'),
  endpoint('endpoint'),
  other('other');

  const Recipient(this.value);

  final String value;

  String get toJS => value;
  static Recipient fromJS(String value) =>
      values.firstWhere((e) => e.value == value);
}

enum RequestType {
  standard('standard'),
  class$('class'),
  vendor('vendor'),
  reserved('reserved');

  const RequestType(this.value);

  final String value;

  String get toJS => value;
  static RequestType fromJS(String value) =>
      values.firstWhere((e) => e.value == value);
}

enum TransferType {
  control('control'),
  interrupt('interrupt'),
  isochronous('isochronous'),
  bulk('bulk');

  const TransferType(this.value);

  final String value;

  String get toJS => value;
  static TransferType fromJS(String value) =>
      values.firstWhere((e) => e.value == value);
}

/// For interrupt and isochronous modes, SynchronizationType and UsageType map
/// to their namesakes within the USB specification.
enum SynchronizationType {
  asynchronous('asynchronous'),
  adaptive('adaptive'),
  synchronous('synchronous');

  const SynchronizationType(this.value);

  final String value;

  String get toJS => value;
  static SynchronizationType fromJS(String value) =>
      values.firstWhere((e) => e.value == value);
}

enum UsageType {
  data('data'),
  feedback('feedback'),
  explicitFeedback('explicitFeedback'),
  periodic('periodic'),
  notification('notification');

  const UsageType(this.value);

  final String value;

  String get toJS => value;
  static UsageType fromJS(String value) =>
      values.firstWhere((e) => e.value == value);
}

class Device {
  Device.fromJS(this._wrapped);

  Device({
    required int device,
    required int vendorId,
    required int productId,
    required int version,
    required String productName,
    required String manufacturerName,
    required String serialNumber,
  }) : _wrapped = $js.Device(
          device: device,
          vendorId: vendorId,
          productId: productId,
          version: version,
          productName: productName,
          manufacturerName: manufacturerName,
          serialNumber: serialNumber,
        );

  final $js.Device _wrapped;

  $js.Device get toJS => _wrapped;
}

class ConnectionHandle {
  ConnectionHandle.fromJS(this._wrapped);

  ConnectionHandle({
    required int handle,
    required int vendorId,
    required int productId,
  }) : _wrapped = $js.ConnectionHandle(
          handle: handle,
          vendorId: vendorId,
          productId: productId,
        );

  final $js.ConnectionHandle _wrapped;

  $js.ConnectionHandle get toJS => _wrapped;
}

class EndpointDescriptor {
  EndpointDescriptor.fromJS(this._wrapped);

  EndpointDescriptor({
    required int address,
    required TransferType type,
    required Direction direction,
    required int maximumPacketSize,
    SynchronizationType? synchronization,
    UsageType? usage,
    int? pollingInterval,
    required ByteBuffer extra_data,
  }) : _wrapped = $js.EndpointDescriptor()
          ..address = address
          ..type = type.toJS
          ..direction = direction.toJS
          ..maximumPacketSize = maximumPacketSize
          ..synchronization = synchronization?.toJS
          ..usage = usage?.toJS
          ..pollingInterval = pollingInterval
          ..extra_data = extra_data.toJS;

  final $js.EndpointDescriptor _wrapped;

  $js.EndpointDescriptor get toJS => _wrapped;

  /// Endpoint address.
  int get address => _wrapped.address;
  set address(int v) {
    _wrapped.address = v;
  }

  /// Transfer type.
  TransferType get type => TransferType.fromJS(_wrapped.type);
  set type(TransferType v) {
    _wrapped.type = v.toJS;
  }

  /// Transfer direction.
  Direction get direction => Direction.fromJS(_wrapped.direction);
  set direction(Direction v) {
    _wrapped.direction = v.toJS;
  }

  /// Maximum packet size.
  int get maximumPacketSize => _wrapped.maximumPacketSize;
  set maximumPacketSize(int v) {
    _wrapped.maximumPacketSize = v;
  }

  /// Transfer synchronization mode (isochronous only).
  SynchronizationType? get synchronization =>
      _wrapped.synchronization?.let(SynchronizationType.fromJS);
  set synchronization(SynchronizationType? v) {
    _wrapped.synchronization = v?.toJS;
  }

  /// Endpoint usage hint.
  UsageType? get usage => _wrapped.usage?.let(UsageType.fromJS);
  set usage(UsageType? v) {
    _wrapped.usage = v?.toJS;
  }

  /// Polling interval (interrupt and isochronous only).
  int? get pollingInterval => _wrapped.pollingInterval;
  set pollingInterval(int? v) {
    _wrapped.pollingInterval = v;
  }

  /// Extra descriptor data associated with this endpoint.
  ByteBuffer get extra_data => _wrapped.extra_data.toDart;
  set extra_data(ByteBuffer v) {
    _wrapped.extra_data = v.toJS;
  }
}

class InterfaceDescriptor {
  InterfaceDescriptor.fromJS(this._wrapped);

  InterfaceDescriptor({
    required int interfaceNumber,
    required int alternateSetting,
    required int interfaceClass,
    required int interfaceSubclass,
    required int interfaceProtocol,
    String? description,
    required List<EndpointDescriptor> endpoints,
    required ByteBuffer extra_data,
  }) : _wrapped = $js.InterfaceDescriptor()
          ..interfaceNumber = interfaceNumber
          ..alternateSetting = alternateSetting
          ..interfaceClass = interfaceClass
          ..interfaceSubclass = interfaceSubclass
          ..interfaceProtocol = interfaceProtocol
          ..description = description
          ..endpoints = endpoints.toJSArray((e) => e.toJS)
          ..extra_data = extra_data.toJS;

  final $js.InterfaceDescriptor _wrapped;

  $js.InterfaceDescriptor get toJS => _wrapped;

  /// The interface number.
  int get interfaceNumber => _wrapped.interfaceNumber;
  set interfaceNumber(int v) {
    _wrapped.interfaceNumber = v;
  }

  /// The interface alternate setting number (defaults to `0</code).
  int get alternateSetting => _wrapped.alternateSetting;
  set alternateSetting(int v) {
    _wrapped.alternateSetting = v;
  }

  /// The USB interface class.
  int get interfaceClass => _wrapped.interfaceClass;
  set interfaceClass(int v) {
    _wrapped.interfaceClass = v;
  }

  /// The USB interface sub-class.
  int get interfaceSubclass => _wrapped.interfaceSubclass;
  set interfaceSubclass(int v) {
    _wrapped.interfaceSubclass = v;
  }

  /// The USB interface protocol.
  int get interfaceProtocol => _wrapped.interfaceProtocol;
  set interfaceProtocol(int v) {
    _wrapped.interfaceProtocol = v;
  }

  /// Description of the interface.
  String? get description => _wrapped.description;
  set description(String? v) {
    _wrapped.description = v;
  }

  /// Available endpoints.
  List<EndpointDescriptor> get endpoints => _wrapped.endpoints.toDart
      .cast<$js.EndpointDescriptor>()
      .map((e) => EndpointDescriptor.fromJS(e))
      .toList();
  set endpoints(List<EndpointDescriptor> v) {
    _wrapped.endpoints = v.toJSArray((e) => e.toJS);
  }

  /// Extra descriptor data associated with this interface.
  ByteBuffer get extra_data => _wrapped.extra_data.toDart;
  set extra_data(ByteBuffer v) {
    _wrapped.extra_data = v.toJS;
  }
}

class ConfigDescriptor {
  ConfigDescriptor.fromJS(this._wrapped);

  ConfigDescriptor({
    required bool active,
    required int configurationValue,
    String? description,
    required bool selfPowered,
    required bool remoteWakeup,
    required int maxPower,
    required List<InterfaceDescriptor> interfaces,
    required ByteBuffer extra_data,
  }) : _wrapped = $js.ConfigDescriptor()
          ..active = active
          ..configurationValue = configurationValue
          ..description = description
          ..selfPowered = selfPowered
          ..remoteWakeup = remoteWakeup
          ..maxPower = maxPower
          ..interfaces = interfaces.toJSArray((e) => e.toJS)
          ..extra_data = extra_data.toJS;

  final $js.ConfigDescriptor _wrapped;

  $js.ConfigDescriptor get toJS => _wrapped;

  /// Is this the active configuration?
  bool get active => _wrapped.active;
  set active(bool v) {
    _wrapped.active = v;
  }

  /// The configuration number.
  int get configurationValue => _wrapped.configurationValue;
  set configurationValue(int v) {
    _wrapped.configurationValue = v;
  }

  /// Description of the configuration.
  String? get description => _wrapped.description;
  set description(String? v) {
    _wrapped.description = v;
  }

  /// The device is self-powered.
  bool get selfPowered => _wrapped.selfPowered;
  set selfPowered(bool v) {
    _wrapped.selfPowered = v;
  }

  /// The device supports remote wakeup.
  bool get remoteWakeup => _wrapped.remoteWakeup;
  set remoteWakeup(bool v) {
    _wrapped.remoteWakeup = v;
  }

  /// The maximum power needed by this device in milliamps (mA).
  int get maxPower => _wrapped.maxPower;
  set maxPower(int v) {
    _wrapped.maxPower = v;
  }

  /// Available interfaces.
  List<InterfaceDescriptor> get interfaces => _wrapped.interfaces.toDart
      .cast<$js.InterfaceDescriptor>()
      .map((e) => InterfaceDescriptor.fromJS(e))
      .toList();
  set interfaces(List<InterfaceDescriptor> v) {
    _wrapped.interfaces = v.toJSArray((e) => e.toJS);
  }

  /// Extra descriptor data associated with this configuration.
  ByteBuffer get extra_data => _wrapped.extra_data.toDart;
  set extra_data(ByteBuffer v) {
    _wrapped.extra_data = v.toJS;
  }
}

class ControlTransferInfo {
  ControlTransferInfo.fromJS(this._wrapped);

  ControlTransferInfo({
    required Direction direction,
    required Recipient recipient,
    required RequestType requestType,
    required int request,
    required int value,
    required int index,
    int? length,
    ByteBuffer? data,
    int? timeout,
  }) : _wrapped = $js.ControlTransferInfo(
          direction: direction.toJS,
          recipient: recipient.toJS,
          requestType: requestType.toJS,
          request: request,
          value: value,
          index: index,
          length: length,
          data: data?.toJS,
          timeout: timeout,
        );

  final $js.ControlTransferInfo _wrapped;

  $js.ControlTransferInfo get toJS => _wrapped;
}

class GenericTransferInfo {
  GenericTransferInfo.fromJS(this._wrapped);

  GenericTransferInfo({
    required Direction direction,
    required int endpoint,
    int? length,
    ByteBuffer? data,
    int? timeout,
  }) : _wrapped = $js.GenericTransferInfo(
          direction: direction.toJS,
          endpoint: endpoint,
          length: length,
          data: data?.toJS,
          timeout: timeout,
        );

  final $js.GenericTransferInfo _wrapped;

  $js.GenericTransferInfo get toJS => _wrapped;
}

class IsochronousTransferInfo {
  IsochronousTransferInfo.fromJS(this._wrapped);

  IsochronousTransferInfo({
    required GenericTransferInfo transferInfo,
    required int packets,
    required int packetLength,
  }) : _wrapped = $js.IsochronousTransferInfo(
          transferInfo: transferInfo.toJS,
          packets: packets,
          packetLength: packetLength,
        );

  final $js.IsochronousTransferInfo _wrapped;

  $js.IsochronousTransferInfo get toJS => _wrapped;
}

class TransferResultInfo {
  TransferResultInfo.fromJS(this._wrapped);

  TransferResultInfo({
    int? resultCode,
    ByteBuffer? data,
  }) : _wrapped = $js.TransferResultInfo()
          ..resultCode = resultCode
          ..data = data?.toJS;

  final $js.TransferResultInfo _wrapped;

  $js.TransferResultInfo get toJS => _wrapped;

  /// A value of `0` indicates that the transfer was a success.
  /// Other values indicate failure.
  int? get resultCode => _wrapped.resultCode;
  set resultCode(int? v) {
    _wrapped.resultCode = v;
  }

  /// The data returned by an input transfer. `undefined` for output
  /// transfers.
  ByteBuffer? get data => _wrapped.data?.toDart;
  set data(ByteBuffer? v) {
    _wrapped.data = v?.toJS;
  }
}

class DeviceFilter {
  DeviceFilter.fromJS(this._wrapped);

  DeviceFilter({
    int? vendorId,
    int? productId,
    int? interfaceClass,
    int? interfaceSubclass,
    int? interfaceProtocol,
  }) : _wrapped = $js.DeviceFilter(
          vendorId: vendorId,
          productId: productId,
          interfaceClass: interfaceClass,
          interfaceSubclass: interfaceSubclass,
          interfaceProtocol: interfaceProtocol,
        );

  final $js.DeviceFilter _wrapped;

  $js.DeviceFilter get toJS => _wrapped;
}

class EnumerateDevicesOptions {
  EnumerateDevicesOptions.fromJS(this._wrapped);

  EnumerateDevicesOptions({
    int? vendorId,
    int? productId,
    List<DeviceFilter>? filters,
  }) : _wrapped = $js.EnumerateDevicesOptions(
          vendorId: vendorId,
          productId: productId,
          filters: filters?.toJSArray((e) => e.toJS),
        );

  final $js.EnumerateDevicesOptions _wrapped;

  $js.EnumerateDevicesOptions get toJS => _wrapped;
}

class EnumerateDevicesAndRequestAccessOptions {
  EnumerateDevicesAndRequestAccessOptions.fromJS(this._wrapped);

  EnumerateDevicesAndRequestAccessOptions({
    required int vendorId,
    required int productId,
    int? interfaceId,
  }) : _wrapped = $js.EnumerateDevicesAndRequestAccessOptions(
          vendorId: vendorId,
          productId: productId,
          interfaceId: interfaceId,
        );

  final $js.EnumerateDevicesAndRequestAccessOptions _wrapped;

  $js.EnumerateDevicesAndRequestAccessOptions get toJS => _wrapped;
}

class DevicePromptOptions {
  DevicePromptOptions.fromJS(this._wrapped);

  DevicePromptOptions({
    bool? multiple,
    List<DeviceFilter>? filters,
  }) : _wrapped = $js.DevicePromptOptions(
          multiple: multiple,
          filters: filters?.toJSArray((e) => e.toJS),
        );

  final $js.DevicePromptOptions _wrapped;

  $js.DevicePromptOptions get toJS => _wrapped;
}
